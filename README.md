<h1 align="center">
  <img src="https://github.com/CharlotteFallices/Mea/blob/master/icon.png?raw=true" alt="icon" width="200" height="200">
  <br>Mea<br>
</h1>
<h4 align="center">泛用型形式化编程语言</h4>
<h5 align="center">*The icon 🍥 comes from <a href="https://moegirl.org.cn/神乐Mea">a virtual character</a></h5>

# 引

试问各位有没有想过,我们常说的"数学思维"与"物理思维"有何区别?

既然其哲学基础相同,这种区别的本质就应来源于不同的研究方法:前者将多个等式合而为一,从而建立起不同数值间的关系;后者则研究事物的表现,在相同条件下任不同事物自行演化,再将结果加以对比.这种研究方法的不同导致了思维方式的不同.在下以为,后者较之前者,其根本区别即在于后者存在过程之差异,或者说,后者更倾向于描述一连续过程,而前者则偏好于某一或某些状态.

依鄙人拙见,编程语言,或者说冯·诺依曼架构下的编程语言,是对计算机底层硬件工作方式的抽象.既然如此,其就同样应有"过程"之说.凡是过程就有始末之分,称所有描述其初始状态的值为输入,经过一定处理,所有能描述其结束状态的值的集合称为输出.在整个过程中,需要以不同的方式组织输入的值,进行一些逻辑判断来区分不同的情况并做出改变.在这一过程中还可以引用其它过程,向它们提供一些恰当的值作为输入,再引用其输出结果以降低本身过程的复杂程度.

这些过程便是程序,描述各种组织,处理方法的工具便是编程语言.由于程序可以被描述为$f:{输入}\rightarrow{输出}$,因此我们也常说程序的本质是映射或函数,但又因其具有过程,是对同一内容的不断变化而非两个状态间的关系,故又称其为方法以作区分.

下面请允许我简单概述从输入到输出之间的几种处理方式.

# 基本工作流

在上文中提到过,编程语言描述如何组织与处理数据.这种描述通常是逐行的,就像要求他人去做某事时,我们会逐句写下命令,编程语言中的描述也是一样.

为了避免由于内容过长以至于无法在形式上的一行内呈现,我们曾规定不以换行来区分各行而是在每行结尾处添加`;`,但后来因为这种情况较为少见,因此便改为以形式上的换行区分各行,如有需要可以在形式行结尾处添加`\`以表示该行与下一行事实上表示同一行.

可以通过添加`//`来表示其右边的部分将在运行时被机器忽略,这通常用于记录一些工作原理或抱怨痛苦的编码工作(笑).

一般来说,每行都由一些方法组成,通常还会有一些逻辑判断:

```shell
new a,num,1
if isEqual a,1 then new b,string,"a is one" else new b,string,"a isn't one"
```

一般情况下,会通过加入`()`与`{}`来帮助划分结构:

```kotlin
new(a,num,1)
if(isEqual(a,1)){
	new(b,string,"a is one")
}else{
	new(b,string,"a isn't one")
}
```
后者中并没有添加`then`标识符,因为在通过`()`进行划分后起到了与`then`同样的效果,在前者中也同样可以这样使用:

```kotlin
if(isEqual a,1) new b,string,"a is one" else new b,string,"a isn't one"
```

更多关于逻辑判断的内容会在[逻辑判断](#逻辑判断)一节中介绍.

## 对象

在上文中提到过,我们要对输入的数据进行组织与处理,其中的组织便体现在通过数据构建不同的对象上.

对象具有属性与类型,对象具有何种属性由其类型决定.

基本类型共有三种:数值,字符串与逻辑类型,分别对应`num`,`string`与`bool`.其中`string`类型的值应在两端添加`""`,`bool`类型的对象只具有`True`与`False`两种值,用以表示逻辑判断中的真假.更多关于类型的内容会在类型一节中介绍.

除上文中通过`new()`来声明对象以外,按照惯例,还可以直接写作`object:type=value`的形式:

```kotlin
a:num=1
```

如果对象已经声明,改变对象的值时不再需要指定类型:

```kotlin
a=sum(a,1)
```

声明对象的具体实现,在原理上通常是依据其类型在内存上划分出一定空间,并将对象各个属性的值储存于其中.上面使`a`为`1`事实上是使`a`的`value`属性为`"1"`,一般情况下,`a`的`value`属性应以`a.value`表示:

```kotlin
a:num=null
a.value="1"
```

首先将`a`声明为空,再将`a.value`赋值为`"1"`,这种方式在本例中与直接声明等价,但在某些情况下则有一些差别:

```kotlin
a:num=0.1
```

`num`类型对象共有三种属性:`value`,`point`与`flag`,其中`point`用于指示小数点所在的位置,`flag`用于标识正负.`value`是一个只包含数字的字符串,在存在小数点与符号的情况下,单独声明`value`会造成这些属性的遗失.

对象还可以被声明为列表,列表本身也是一种对象,一个列表内可以存放多个对象,声明时应在类型两边添加`[]`,在值两边添加`{}`;

```kotlin
a:[num]={1,2,3}
```
可以为列表中的每一个值命名,也可以在访问时直接使用位数访问.访问列表中的某个对象时应在名称或位数两边添加`[]`:

```kotlin
a[0]=plus(a[0],1)
b:[num]={"first":1,"second":2}
b["first"]=a[0]
```

先将`a`的第`0`位数(第一个)加一,再将其作为`b`中的`first`.值得一提的是,此处的`=`会将`a`的第`0`位上的对象作为`b`中的`first`而不是使`b`中`first`的对象的值为其的值.

这主要是因为列表事实上只是对多个对象在内存上的位置进行索引,换句话说,一个列表中真正填充的值是一些地址而非对象本身的值,因此,也可以创建没有具体内容的列表,只需指明类型与个数即可:

```kotlin
a:[num]=[3]
```

并且,可以通过在声明时添加多个`[]`以创建多维列表:

```kotlin
a:[num]=[3][5]
a[0][1]=1
```

以上便声明了一个3*5的二维列表,并使(0,1)的位置上为一个值为`1`的对象.

## 方法

在上文中提到过,我们通过引用现有的过程降低程序复杂度,这些引用的过程被称为方法.同一方法在不同的环境下可能应以不同的方式工作,我们在此借用了数学当中参数的概念以实现这一点.

引用方法时需要提供方法名,有些方法可能不需要提供参数,如果需要则应写在方法名之后:

```shell
print "test"
```

可以提供不止一个参数,并且可以添加`()`来帮助划分结构:

```kotlin
print("test","233")
```

所有的方法在本质上也是对象,当直接使用它们时获取到的值是它们的输出:

```kotlin
a:num=1
b:num=2
c:num=sum(a,b)
```

当名称与参数(包括这些参数的类型)完全相同时两个方法会被认定为是同一方法.

声明方法的格式与声明对象类似,声明时方法的类型是`func`,但事实上与其输出值的类型相同.输出通过`return()`实现:

```swift
yeeeeee:func=(=>string){
	print("yeeeeee")
  return("yoooooo")
}
```

在声明方法时还可以指定其参数,如果在指定参数时没有指明其类型,则认为使用引用时环境下的同名对象:

```swift
a:num=1
b:num=2
suuuuuum:func=(a:num,b=>num){
	return(sum(a,b))
}
c:num=suuuuuum(b)
```

此时的`c`的值应当是两个`b`相加的结果,因为`suuuuuum:func=(a:num,b=>num)`事实上只要求提供一个参数,`b`是从声明`c`时的环境中获取的,而由于声明`c`的时候传入的参数是`b`的值,因此在`{}`中使用的`a`与`b`都是`b`的值.

值得一提的是,方法通过要求提供参数获取到的是传入对象的值,而非对象本身,因此在方法中修改这些值并不会影响被传入的对象.但是,进一步地,由于列表事实上是一个对其中对象所在内存地址的索引,因此传入列表被传入的值也是这些索引.换句话说,虽然在方法中修改列表不会影响被传入的列表本身,但当尝试修改被索引的对象时,所修改的仍然是那些对象.

有一些运算符用于替代常用的方法:

| a+b      | a-b             | a*b            | a/b            | a==b         | a!=b            | a>b           | a>=b           | a<b            | a<=b             |
| -------- | --------------- | -------------- | -------------- | ------------ | --------------- | ------------- | -------------- | -------------- | ---------------- |
| sum(a,b) | difference(a,b) | multiple(a,b)  | divide(a,b)    | isEqual(a,b) | isNotEuqal(a,b) | isBigger(a,b) | isNotSmaller() | isSmaller()    | isNotBigger(a,b) |
| !a       | a===b           | a!===b         | a%b            | a^b          | a&&b            | a\|\|b        | a^^b           | a<<b           | a>>b             |
| not(a)   | isSame(a,b)     | isNotSame(a,b) | remainder(a,b) | toPower(a,b) | and(a,b)        | or(a,b)       | xor(a,b)       | shiftLeft(a,b) | shiftRight(a,b)  |

事实上,上文中提到过的通过`name:type=value`来替代`new(name,type,value)`的做法也属于此列.`if`标识符虽也能被条件运算符替代,但其并不属于方法当中.

## 逻辑判断

在上文中提到过,过程中的行为会因不同的环境而做出一些改变.一般来说,对当前情况的判断是对某些决定程序工作方式的条件的判断,可以用`if condition then`来表示,并且可以通过`()`与`{}`进行进一步划分:

```kotlin
a:num=0
if a==0 then a=a+1
if(a==1){
	a=a-1
}
```

进一步地,我们可以通过`else if condition`对多个条件进行判断,并且通过`else`设置不符合任一条件时的行为:

```kotlin
a:num=0
if(a==0){
	a=1
}else if(a==1){
	a=0
}else{
	a=-1
}
```

以上程序会导致`a`被赋值为`1`,因为在所有相连的`if`,`else if`与`else`中,只要一次判断成功便不会再继续判断.

特别地,`if(){}else{}`可以被写为条件表达式:

```kotlin
a:num=0
b:num=(a==0:1?-1)
```

条件表达式也可以写作`a if condition else b`的形式:

```kotlin
b:num=1 if a==0 else -1
```

通过`until`标识符,可以使过程不断进行直至满足条件为止:

```kotlin
a:num=0
if(a==0){
	a=a+1
}until(a==5)
```

`until`不一定要在`if`之后使用.事实上,`until`在具体实现时声明了一个不具有方法名的方法,并且在每次执行完后判断条件以此决定是否要再引用自己.这个方法的参数为过程中所使用到的所有已声明的对象,并且这些参数被分配的地址与原本的已声明的对象的地址相同,换句话说,对这些参数的修改等价于对原本对象的修改.
